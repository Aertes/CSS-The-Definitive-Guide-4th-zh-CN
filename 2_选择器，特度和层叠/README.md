#选择器，特度和层叠

#1、选择器

CSS的一个主要优势——尤其对设计者而言——是它能够轻松地把一组样式应用到同一类型的所有元素。印象不够深刻？想象这样的场景：通过编辑单行CSS，你可以修改所有标题的颜色。不喜欢正在使用的蓝色？修改一行代码，把它们都变成紫色、黄色、栗色等等任何想要的颜色。这可以让你，设计师，专注于设计而不是繁琐的工作。下次会议中，有人想看绿色标题，你只需要编辑样式然而点击重新加载。瞧!几秒钟就完成了，每个人都可以看到。

当然，CSS不能解决所有问题——比如，它不能用来改变PNG图片的颜色空间，至少现在还不能——但它确实让全局修改变得容易多了。我们先从选择器和结构开始。

##基本样式规则

如上所述，CSS的核心特性是将某些样式应用于文档中的整个元素类型的能力。例如，如果你想把所有`h2`元素的文本显示为灰色，使用老套的HTML，你必须在所有的`h2`元素中插入`<FONT COLOR="gray">...</FONT>`标签：

~~~html
<h2><font color="gray">This is h2 text</font></h2>
~~~

显然，如果你的文档里面有许多`h2`元素，修改过程将是乏味的。更糟糕的是，如果你之后又想把所有的`h2`从灰色变成绿色，你又得重新开始手动设置一遍便签。（没错，以前就是这么干的！）

CSS让你可以创建易于编辑的规则，并把它们应用于所有你定义的文本元素（下一部分将解释规则如何生效）。例如，简单地写一次下面的规则，把所有的`h2`元素都变成灰色：

~~~css
h2 {color: gray;}
~~~

如果你想把所有`h2`的文本变成另一种颜色——比如银色——只要简单地选择（属性）值：

~~~css
h2 {color: silver;}
~~~

###元素选择器

元素选择器通常都是HTML元素，但也有例外。例如，如果CSS文件的样式是用于XML文档的，元素选择器可能会是这样：

~~~css
QUOTE {color: gray;}  BIB {color: red;}  
BOOKTITLE {color: purple;}  
MYElement {color: red;}
~~~

换句话说，文档的元素被用作最基本的选择器。在XML中，选择器可以是任何东西，因为XML允许创建新的标记语言，任何东西都可以作为元素名称。另一方面，如果为HTML文档添加样式，选择器一般是许多HTML元素之一，如`p`，`h3`，`em`，`a`,甚至`html`元素本身。例如：

~~~css
html {color: black;}  
h1 {color: gray;}  h2 {color: silver;}
~~~

样式表的结果在图1-1中展示：

![图1-1：简单文档的简单样式](figure1-1.png)

*图1-1：简单文档的简单样式*

当你直接全局地给元素设置了样式，你可以把样式从一个样式移到另一个样式上。如果你想要图1-1中的段落文本而不是`h1`元素是灰色，没问题，只要把`h1`选择器换成`p`就行了;

~~~css
html {color: black;}  
p {color: gray;}  h2 {color: silver;}
~~~

结果在图1-2中展示:

![图1-2：把样式从一个元素移到另一个上](figure1-2.png)

*图1-2：把样式从一个元素移到另一个上*

###声明和关键字

声明块包含一或多条声明。一条声明的格式总是一个**属性**后面跟着一个冒号，然后一个**值**后面跟着一个分号。冒号和分号后面可以有零或多个空白。几乎所有的值都是单个关键字或者空白分隔的当前属性允许的多个关键字列表。如果在一条声明中使用了错误的属性或值，整条规则都会被忽略。因此，下面这两条声明是无效的：

~~~css
brain-size: 2cm; /* unknown property 'brain-size' */  
color: ultraviolet; /* unknown value 'ultraviolet' */
~~~

属性值可以使用多个关键字的时候，关键字通常用空白分隔。很多属性可以接收多个关键字（如`font`属性），但不是全部属性都可以。如果想为段落字体设置中等大小的Helvetica字体，就像在图1-3中显示的：

![图1-3：属性值包含多个关键字的结果](figure1-3.png)

*图1-3：属性值包含多个关键字的结果*

规则将是这样：

~~~css
p {font: medium Helvetica;}
~~~

注意两个关键字`medium`和`Helvetica`之间的空白（第一个是字体大小，第二个是字体名称）。空白使用户代理可以分辨出两个关键字并正确地使用它们。分号指明当前声明已经结束。

这些空白分隔的词被称为关键字，因为它们在一起组成了属性的值。例如下面这个假象的规则：

~~~css
rainbow: red orange yellow green blue indigo violet;
~~~

当然不存在`rainbow`这个属性，它只是被当做例子来进行说明。`rainbow`的值是`red orange yellow green blue indigo violet`，这7个关键字放在一起组成了一个唯一的值。我们可以像下面这样重新定义`rainbow`的值：

~~~css
rainbow: infrared red orange yellow green blue indigo violet ultraviolet;
~~~

现在我们有了一个由9个而不是7个关键字组成的新值。虽然这两个值看起来很像，但他们就像0和1一样是不同而且唯一的。这里好像有点抽象，但它对理解一些特性和层叠（在本书后面部分讨论）的微妙影响是至关重要的。

_**空白分隔有些例外，大部分是CSS3引入的。最初只有一个例外：`font`属性值中允许使用正斜杠（/）。现在有几个类似这样的符号被用于属性值中，以及有些属性的值使用逗号分隔。**_

这些是基础的简单声明，但它们也可以变得非常复杂。下一部分我们将要展示CSS有多么强大。

##分组

如我们所见，把一个简单样式应用在一个简单选择器上是非常简单的，但是如果你想把相同的样式引用在多个元素上应该怎么做呢？这种场景下，你会想要把多个选择器或多个样式应用在一个或一组元素上。

###分组选择器

如果你想让`h2`元素和段落都显示灰色文本，最简单的方式是使用下面的声明：

~~~css
h2, p {color: gray;}
~~~

把`h2`和`p`选择器放置在规则左边并用逗号分隔，这种方式定义了一条把右边样式（`color: gray;`）应用于两个选择器的规则。逗号告诉浏览器规则里面是两个不同的选择器，如果去掉逗号，会使语句变成另外一条含义完全不同的规则。（参见后面的章节“后代选择器”。）

分组的选择器数目没有限制，例如，如果你想把一大堆元素都设置成灰色，你可以用这样的规则：

~~~css
body, table, th, td, h1, h2, h3, h4, p, pre, strong, em, b, i {color: gray;}
~~~

分组允许开发者可以大幅压缩样式分配，从而使样式表更精简。下面两种写法的结果是一样的，哪一种更容易输入是很明显的：

~~~css
h1 {color: purple;}  
h2 {color: purple;}  
h3 {color: purple;}  
h4 {color: purple;}  
h5 {color: purple;}  
h6 {color: purple;}  
h1, h2, h3, h4, h5, h6 {color: purple;}
~~~

分组允许做出一些有趣的选择，例如下面例子中的写法都是等效的，每个例子展示了一种分组选择器和声明的不同方式：

~~~css
/* group 1 */h1 {color: silver; background: white;}  
h2 {color: silver; background: gray;}  
h3 {color: white; background: gray;}  
h4 {color: silver; background: white;}  
b {color: gray; background: white;}  
/* group 2 */h1, h2, h4 {color: silver;} 
h2, h3 {background: gray;} 
h1, h4, b {background: white;} 
h3 {color: white;}b {color: gray;}

/* group 3 */h1, h4 {color: silver; background: white;} 
h2 {color: silver;}
h3 {color: white;}h2, h3 {background: gray;}b {color: gray; background: white;}
~~~

每个例子都会生成图1-4显示的结果。（这些样式使用的分组声明，将在接下来的“分组声明”中探讨。）

![图4：等效样式表的结果](figure1-4.png)

*图4：等效样式表的结果*

####通配选择器

CSS2引入了一个新的简单选择器叫做**通配选择器**，使用星号（`*`）标注。这个选择器就像一张百搭牌，可以匹配所有元素。例如，要把文档中的每个元素（文本）都设置成红色，可以这样写：

~~~css
* {color: red;}
~~~

此声明等效于一个列出文档中所有元素的分组选择器。通配选择器允许你以一种有效的方式为文档中每个元素的`color`属性设置一个值`red`。但是，要注意，虽然通配选择器很方便，但它可能带来意外的后果，我们将在本书后面的部分讨论。

###分组声明

规则中分组选择器，也可以分组声明。假如你想把所有的`h1`元素设置为紫色、18像素高的Helvetica字体显示在水色背景上（你不介意闪瞎用户），你可以把样式写成这样：

~~~css
h1 {font: 18px Helvetica;}  
h1 {color: purple;}  h1 {background: aqua;}
~~~

但这种方式是低效的——想象一下为每个元素创建一个10或15个样式的列表！你可以把声明组合在一起来替代前面的写法：

~~~css
h1 {font: 18px Helvetica; color: purple; background: aqua;}
~~~

这种写法和上面的三行样式表是一样的结果。

要注意分组来写的时候每条声明后面的分号至关重要。浏览器会忽略样式表中的空白，因此用户代理要依赖正确的语法来解析样式表。你可以这样格式化样式表：

~~~css
h1 {	font: 18px Helvetica;  
	color: purple;  
	background: aqua;}
~~~

但是，如果漏掉了第二个分号，用户代理会把样式表理解成下面这样：

~~~css
h1 {	font: 18px Helvetica;  	color: purple background: aqua; 
}
~~~

因为`background:`并不是`color`属性的合法值，而且`color`属性只能有一个关键字，因此用户代理会完全忽略`color`声明（包括`background: aqua`的部分）。你可能认为浏览器至少会把`h1`设置成紫色字体但没有水色北京，但是如果浏览器本身的实现是正确的话，你会连紫色的`h1`也看不到，它们会被设置成默认颜色（通常是黑色）和透明背景（默认）。声明`font: 18px Helvetica`将会依然生效，因为它是以一个分号正确结束的。

_**虽然从技术上来讲，最后一条声明后面的分号并不是必需的，但通常为它加上分号是一个好的实践。首先，丢失分号是渲染错误的最常见的原因之一，遵循这个实践可以使你保持使用分号结束声明的良好习惯；其次，当你为样式规则追加一条声明的时候，不必担心前面的声明后面是否忘了插入分号。在每条声明后都跟随一个分号来避免上面的问题。**_

分组声明和分组选择器一起使用，可以方便地保持样式表简洁、富有表现力和易于维护。

###分组一切

选择器和声明都可以分组，在单条样式中使用这两种分组，可以使用很少的声明式定义非常复杂的样式。如果你要把一些复杂样式应用在文档的所有标题上，而且为他们应用相同的样式，应该怎么做呢？下面是做法：

~~~css
h1, h2, h3, h4, h5, h6 {color: gray; background: white; padding: 0.5em; 
	border: 1px solid black; font-family: Charcoal, sans-serif;}
~~~

因为分组了选择器，右侧的规则会应用在列出的所有标题上；分组声明表明所有列出的样式都会被应用在左侧的选择器上。规则显示的结果如图1-5。

![图1-5：分组选择器和规则](figure1-5.png)

*图1-5：分组选择器和规则*

这种方案比下面的方案更好：

~~~css
h1 {color: gray;}  h2 {color: gray;}  h3 {color: gray;}  h4 {color: gray;}  h5 {color: gray;}  h6 {color: gray;}  h1 {background: white;}  
h2 {background: white;}  
h3 {background: white;}  
...
~~~

等等还有许多行。你也**可以**像这样写出长长的样式，但我建议你不要这样做——编辑它们就像到处写`font`标签一样无聊。

可以在选择器中加入更多的表达式，并以跨元素的方式应用样式。当然，要得到这么强大的东西需要付出一些工作，但这是值得的。

##类和ID选择器
###类选择器
###多个类
###ID选择器
###决定使用Class还是ID
##属性选择器
###简单属性选择器
###基于准确属性值选择
###基于部分属性值选择
###一个特别的属性选择类型
##使用文档结构
###理解父-子关系
###后代选择器
###选择子元素
###选择相邻兄弟元素
###选择跟随兄弟元素
##伪类选择器
###组合伪类
###结构性伪类
###动态伪类
###UI状态伪类
###`:target`伪类
###`:lang`伪类
###否定伪类
##伪元素选择器
###样式化第一个字母
###样式化第一行
###`::first-letter`和`::first-line`的限制
###在元素之前或之后样式化（或创建）内容
#特度和层叠
##特度
###声明和特度
###全局选择器特度
###ID和属性选择器特度
###行内样式特度
###重要性
##继承
##层叠
###按重要性和来源排序
###按特度排序
###按顺序排序
###非CSS显示标识
#总结